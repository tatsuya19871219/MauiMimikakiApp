@startuml Mimikaki
class MimiViewBox
{
    + Bounds : Rect <<required>>
    + GetBoundsAsync() : Task<Rect>
}

class MimiRegionViewBox
{
    + Bounds : Rect
    ~ MimiRegionViewBox()
}


' Views
class MimikakiView <<V, HotPink>>
{
    + ImageFilename : string <<required>>
    + MimikakiView(viewbox : MimiViewBox, outer : Path, inner : Path, hole : Path)
    + RegisterMessages(): void
    - InvalidateRegions() : void
    - AddFloatingDirt(dirtObject : Shape) : void
}


' ViewModels
class MimikakiViewModel
{
    - tracker : PositionTracker
    + TopRegionDrawable : MimiRegionDrawable <<observable>>
    + CenterRegionDrawable : MimiRegionDrawable <<observable>>
    + BottomRegionDrawable : MimiRegionDrawable <<observable>>
    - topRegion : MimiRegion
    - centerRegion : MimiRegion
    - bottomRegion : MimiRegion
    - tracker : PositionTracker
    ~ MimikakiViewModel(viewbox : MimiViewBox, outer : Path, inner : Path, hole : Path)
    - Initialize();
    - RunTrackerProcess(updateInterval : int) : void
    ~ TargetImage_SizeChanged(sender : object, e : EventArgs) : void
}


' Drawable
class MimiRegionDrawable
{
    + RegionWidthRequest : double
    + RegionHeightRequest : double
    + RegionOffsetX : double
    + RegionOffsetY : double
    - mimiRegion : MimiRegion
    + MimiRegionDrawable(mimiRegion : MimiRegion, padding : double)
    + Draw(canvas : ICanvas, dirtyRect : RectF) : void
    - VisualizeHairs(canvas : ICanvas, color : Color) : void
    - VisualizeDirts(canvas : ICanvas, color : Color) : void
}


' Page
class MainPage <<(P, LimeGreen)>>
{
    + MainPage()
    - RegisterTrackerMessages() : void
    - PrepareSEPlayer(audioManager : IAudioManager) : void
}

' Config
' class MimikakiConfig
' {

' }

' Library
package TakeMauiEasy
{
    class EasyTasks
    class PositionTracker
}

' arrows
MimikakiViewModel -left-> MimiViewBox
MimikakiViewModel --> PositionTracker
MimikakiViewModel o- "3" MimiRegionDrawable

MimikakiViewModel o-- "3" MimiRegionViewBox
MimikakiViewModel o- "3" MimiRegion

MimikakiView ..> MimikakiViewModel : <create>

MainPage -> MimikakiView

'MimiRegionDrawable --|> IDrawable
MimiRegionDrawable --> MimiRegion

@enduml

@startuml MimiRegion
' Models
class MimiRegion
{
    + Bounds : Rect
    + Hairs : IEnumerable<MimiHair>
    + Dirts : IEnumerable<MimiDirt>
    - internalRegion : InternalRegion
    - hairList : List<MimiHair>
    - dirtList : List<MimiDirt>
    + MimiRegion(pathF : PathF, dx : int, dy : int)
    - InitializeMimiHair(density : double)
    ~ GenerateMimiDirt() : void
    ~ RemoveMimiDirt() : void
    ~ Contains(point : Point) : bool
}

interface ITrackerListener
{
    OnMove(position : Point, velocity : Point, milliSecUpdateInterval : double) : void
}

class MimiHair
{
    - origin : Point
    - position : Point
    - springConst : double
    + MimiHair(position : Point)
    + GetPosition() : Point
    + UpdatePosition(force : Point) : void
}

class MimiDirt
{
    - position : Point
    - hardness : double
    + MimiDirt(position : Point, hardness : double)
}

' RegionModels
abstract AbstractRegion
{
    # bounds : Rect
    ~ AbstractRegion(edgeSet : EdgeSet)
    {abstract} ~ ContainsInRegion(point : Point) : bool
    {abstract} ~ OnBoundary(point : Point) : bool
    {abstract} ~ DistanceFromBoundary(point : Point) : double
    - GetMinAndMaxPoints(points : List<Point>, minPoint : out Point, maxPoint : out Point) : void
}

class InternalRegion
{
    ~ Bounds : Rect
    - subRegions : List<SubRegion>
    + InternalRegion(edgeSet : EdgeSet, dx : int, dy : int)
    + GeneratePointInRegion() : Point
}

class SubRegion
{
    - gridX : List<int>
    - gridY : List<int>
    - isInner : bool[,] <<read only>>
    - isBoundary : bool[,] <<read only>>
    + SubRegion(edgeSet : EdgeSet, sharedEdges : List<Edge>, dx : int, dy : int)
    - FillBoundaryPoints(edgeSet : EdgeSet, sharedEdges : List<Edges>) : void
    - FillInternalRegion() : void
    '- ConvertToRegionIndex(x : double, y : double) : (int, int)
}

class EdgeSet <<IEnumerable>>
{
    - pathF : PathF
    - edges : List<Edge>
    - verticies : List<Point>
    ~ IsClosed : bool
    ~ EdgeSet(pathF : PathF)
    ~ Separate() : List<EdgeSet>
    ~ GetVerticies() : List<PointF>
}

class Edge <<(R, LightGreen) record>>
{
    + Edge(a : PointF, b : PointF)
    + Equals(target : Edge) : bool
}

' arrows
MimiRegion -> InternalRegion
MimiRegion *-- MimiHair
MimiRegion *-- MimiDirt

InternalRegion *- SubRegion
InternalRegion --|> AbstractRegion
SubRegion --|> AbstractRegion

MimiHair ..|> ITrackerListener
MimiDirt ..|> ITrackerListener

EdgeSet *-- Edge

InternalRegion -[hidden]- EdgeSet

@enduml

@startuml MimikakiMessages

namespace Messages{

    class TrackerUpdateMessage <<(M, Orange) Message>>
    {
        ~ TrackerUpdateMessage(state : PositionTrackerState)
    }

    class TrackerOnMimiMessage <<(M, Orange) Message>>
    {
        ~ TrackerOnMimiMessage(state : PositionTrackerState)
    }

    class MimiViewInvalidateMessage <<(M, Orange) Message>>
    {
        ~ MimiViewInvalidateMessage(value : string)
    }

    class FloatingDirtGenerateMessage <<(M, Orange) Message>>
    {
        ~ FloatingDirtGenerateMessage(dirt : Shape)
    }

    ' Force to align vertically
    TrackerUpdateMessage -[hidden]- TrackerOnMimiMessage
    TrackerOnMimiMessage -[hidden]- MimiViewInvalidateMessage
    MimiViewInvalidateMessage -[hidden]- FloatingDirtGenerateMessage

}

MainPage .> Messages.TrackerUpdateMessage : <register>
MainPage .> Messages.TrackerOnMimiMessage : <register>

MimikakiView .left.> Messages.MimiViewInvalidateMessage : <register>
MimikakiView .left.> Messages.FloatingDirtGenerateMessage : <register>

MimikakiViewModel .> Messages.TrackerUpdateMessage : <create>
MimikakiViewModel .> Messages.TrackerOnMimiMessage : <create>
MimikakiViewModel .> Messages.MimiViewInvalidateMessage : <create>
MimikakiViewModel .> Messages.FloatingDirtGenerateMessage : <create>

@enduml